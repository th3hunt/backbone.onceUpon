{"version":3,"sources":["/source/backbone.onceUpon.js","/source/src/backbone.onceUpon.js"],"names":["global","factory","exports","module","require","define","amd","OnceUpon","Backbone","_","this","getOption","target","optionName","options","undefined","bindFromStrings","entity","evt","methods","methodNames","split","each","methodName","method","Error","listenToOnce","bindToFunction","unbindFromStrings","stopListening","unbindToFunction","iterateEvents","bindings","functionCallback","stringCallback","isObject","Marionette","_getValue","isFunction","Once","bindEntityEvents","unbindEntityEvents","extend","View","originalDelegateEvents","prototype","delegateEvents","originalUndelegateEvents","undelegateEvents","apply","arguments","backbone_onceUpon"],"mappings":"CAAA,SAAWA,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,EAAQG,QAAQ,YAAaA,QAAQ,eACnG,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,WAAY,cAAeJ,GAChFD,EAAOO,SAAWN,EAAQD,EAAOQ,SAAUR,EAAOS,IAClDC,KAAM,SAAUF,EAAUC,GAAK,YCCjC,SAASE,GAAUC,EAAQC,GACzB,MAAKD,IAAWC,EAGZD,EAAOE,SAA2CC,SAA/BH,EAAOE,QAAQD,GAC7BD,EAAOE,QAAQD,GAEfD,EAAOC,GANhB,OAYF,QAASG,GAAgBJ,EAAQK,EAAQC,EAAKC,GAC5C,GAAIC,GAAcD,EAAQE,MAAM,MAEhCZ,GAAEa,KAAKF,EAAa,SAAAG,GAClB,GAAIC,GAASZ,EAAOW,EACpB,KAAKC,EACH,KAAM,IAAIC,OAAM,WAAaF,EAAa,4DAE5CX,GAAOc,aAAaT,EAAQC,EAAKM,KAKrC,QAASG,GAAef,EAAQK,EAAQC,EAAKM,GAC3CZ,EAAOc,aAAaT,EAAQC,EAAKM,GAKnC,QAASI,GAAkBhB,EAAQK,EAAQC,EAAKC,GAC9C,GAAIC,GAAcD,EAAQE,MAAM,MAEhCZ,GAAEa,KAAKF,EAAa,SAAAG,GAClB,GAAIC,GAASZ,EAAOW,EACpBX,GAAOiB,cAAcZ,EAAQC,EAAKM,KAKtC,QAASM,GAAiBlB,EAAQK,EAAQC,EAAKM,GAC7CZ,EAAOiB,cAAcZ,EAAQC,EAAKM,GAIpC,QAASO,GAAcnB,EAAQK,EAAQe,EAAUC,EAAkBC,GACjE,GAAKjB,GAAWe,EAAhB,CAKA,IAAKvB,EAAE0B,SAASH,GACd,KAAM,IAAIP,OAAM,0CAIlBO,GAAWI,WAAWC,UAAUL,EAAUpB,GAG1CH,EAAEa,KAAKU,EAAU,SAACb,EAASD,GAIrBT,EAAE6B,WAAWnB,GACfc,EAAiBrB,EAAQK,EAAQC,EAAKC,GAEtCe,EAAetB,EAAQK,EAAQC,EAAKC,MAO1CoB,KAAKC,iBAAmB,SAAS5B,EAAQK,EAAQe,GAC/CD,EAAcnB,EAAQK,EAAQe,EAAUL,EAAgBX,IAG1DuB,KAAKE,mBAAqB,SAAS7B,EAAQK,EAAQe,GACjDD,EAAcnB,EAAQK,EAAQe,EAAUF,EAAkBF,GAS5D,IAAMrB,IACJmC,OAAM,SAACC,GACL,GAAIC,GAAyBD,EAAKE,UAAUC,eACxCC,EAA2BJ,EAAKE,UAAUG,gBAE9CL,GAAKE,UAAUC,eAAiB,WAC9BF,EAAuBK,MAAMvC,KAAMwC,WACnCV,iBAAiB9B,KAAMA,KAAMC,EAAUD,KAAM,oBAG/CiC,EAAKE,UAAUG,iBAAmB,WAChCP,mBAAmB/B,KAAMA,KAAMC,EAAUD,KAAM,mBAC/CqC,EAAyBE,MAAMvC,KAAMwC,aA1G3C1C,GAAAD,SAAAA,CAAA,IAAA4C,GAAA5C,CDsHE,OAAO4C","file":"backbone.onceUpon.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('backbone'), require('underscore')) :\n  typeof define === 'function' && define.amd ? define(['backbone', 'underscore'], factory) :\n  global.OnceUpon = factory(global.Backbone, global._)\n}(this, function (Backbone, _) { 'use strict';\n\n  // Shamelessly copying from Marionette bind-entity-events\n\n  function getOption(target, optionName) {\n    if (!target || !optionName) {\n      return;\n    }\n    if (target.options && (target.options[optionName] !== undefined)) {\n      return target.options[optionName];\n    } else {\n      return target[optionName];\n    }\n  };\n\n  // Bind the event to handlers specified as a string of\n  // handler names on the target object\n  function bindFromStrings(target, entity, evt, methods) {\n    let methodNames = methods.split(/\\s+/);\n\n    _.each(methodNames, methodName => {\n      let method = target[methodName];\n      if (!method) {\n        throw new Error('Method \"' + methodName + '\" was configured as an event handler, but does not exist.');\n      }\n      target.listenToOnce(entity, evt, method);\n    });\n  }\n\n  // Bind the event to a supplied callback function\n  function bindToFunction(target, entity, evt, method) {\n    target.listenToOnce(entity, evt, method);\n  }\n\n  // Bind the event to handlers specified as a string of\n  // handler names on the target object\n  function unbindFromStrings(target, entity, evt, methods) {\n    var methodNames = methods.split(/\\s+/);\n\n    _.each(methodNames, methodName => {\n      var method = target[methodName];\n      target.stopListening(entity, evt, method);\n    });\n  }\n\n  // Bind the event to a supplied callback function\n  function unbindToFunction(target, entity, evt, method) {\n    target.stopListening(entity, evt, method);\n  }\n\n  // generic looping function\n  function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n    if (!entity || !bindings) {\n      return;\n    }\n\n    // type-check bindings\n    if (!_.isObject(bindings)) {\n      throw new Error('Bindings must be an object or function.');\n    }\n\n    // allow the bindings to be a function\n    bindings = Marionette._getValue(bindings, target);\n\n    // iterate the bindings and bind them\n    _.each(bindings, (methods, evt) => {\n\n      // allow for a function as the handler,\n      // or a list of event names as a string\n      if (_.isFunction(methods)) {\n        functionCallback(target, entity, evt, methods);\n      } else {\n        stringCallback(target, entity, evt, methods);\n      }\n\n    });\n  }\n\n  // Export Public API\n  Once.bindEntityEvents = function(target, entity, bindings) {\n    iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);\n  };\n\n  Once.unbindEntityEvents = function(target, entity, bindings) {\n    iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);\n  };\n\n  /**\n   *\n   * MyView = Backbone.OnceUpon.extend(Backbone.View) for all views\n   *\n   */\n\n  const OnceUpon = {\n    extend(View) {\n      let originalDelegateEvents = View.prototype.delegateEvents;\n      let originalUndelegateEvents = View.prototype.undelegateEvents;\n\n      View.prototype.delegateEvents = function() {\n        originalDelegateEvents.apply(this, arguments);\n        bindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n      };\n\n      View.prototype.undelegateEvents = function() {\n        unbindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n        originalUndelegateEvents.apply(this, arguments);\n      };\n    }\n  };\n\n  Backbone.OnceUpon = OnceUpon;\n\n  var backbone_onceUpon = OnceUpon;\n\n  return backbone_onceUpon;\n\n}));\n","import Backbone from 'backbone';\nimport _ from 'underscore';\n\n// Shamelessly copying from Marionette bind-entity-events\n\nfunction getOption(target, optionName) {\n  if (!target || !optionName) {\n    return;\n  }\n  if (target.options && (target.options[optionName] !== undefined)) {\n    return target.options[optionName];\n  } else {\n    return target[optionName];\n  }\n};\n\n// Bind the event to handlers specified as a string of\n// handler names on the target object\nfunction bindFromStrings(target, entity, evt, methods) {\n  let methodNames = methods.split(/\\s+/);\n\n  _.each(methodNames, methodName => {\n    let method = target[methodName];\n    if (!method) {\n      throw new Error('Method \"' + methodName + '\" was configured as an event handler, but does not exist.');\n    }\n    target.listenToOnce(entity, evt, method);\n  });\n}\n\n// Bind the event to a supplied callback function\nfunction bindToFunction(target, entity, evt, method) {\n  target.listenToOnce(entity, evt, method);\n}\n\n// Bind the event to handlers specified as a string of\n// handler names on the target object\nfunction unbindFromStrings(target, entity, evt, methods) {\n  var methodNames = methods.split(/\\s+/);\n\n  _.each(methodNames, methodName => {\n    var method = target[methodName];\n    target.stopListening(entity, evt, method);\n  });\n}\n\n// Bind the event to a supplied callback function\nfunction unbindToFunction(target, entity, evt, method) {\n  target.stopListening(entity, evt, method);\n}\n\n// generic looping function\nfunction iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n  if (!entity || !bindings) {\n    return;\n  }\n\n  // type-check bindings\n  if (!_.isObject(bindings)) {\n    throw new Error('Bindings must be an object or function.');\n  }\n\n  // allow the bindings to be a function\n  bindings = Marionette._getValue(bindings, target);\n\n  // iterate the bindings and bind them\n  _.each(bindings, (methods, evt) => {\n\n    // allow for a function as the handler,\n    // or a list of event names as a string\n    if (_.isFunction(methods)) {\n      functionCallback(target, entity, evt, methods);\n    } else {\n      stringCallback(target, entity, evt, methods);\n    }\n\n  });\n}\n\n// Export Public API\nOnce.bindEntityEvents = function(target, entity, bindings) {\n  iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);\n};\n\nOnce.unbindEntityEvents = function(target, entity, bindings) {\n  iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);\n};\n\n/**\n *\n * MyView = Backbone.OnceUpon.extend(Backbone.View) for all views\n *\n */\n\nconst OnceUpon = {\n  extend(View) {\n    let originalDelegateEvents = View.prototype.delegateEvents;\n    let originalUndelegateEvents = View.prototype.undelegateEvents;\n\n    View.prototype.delegateEvents = function() {\n      originalDelegateEvents.apply(this, arguments);\n      bindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n    };\n\n    View.prototype.undelegateEvents = function() {\n      unbindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n      originalUndelegateEvents.apply(this, arguments);\n    };\n  }\n};\n\nBackbone.OnceUpon = OnceUpon;\n\nexport default OnceUpon;\n"],"sourceRoot":"/source/"}