{"version":3,"sources":["backbone.onceUpon.js","src/backbone.onceUpon.js"],"names":[],"mappings":"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","file":"backbone.onceUpon.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('backbone'), require('underscore')) :\n  typeof define === 'function' && define.amd ? define(['backbone', 'underscore'], factory) :\n  global.OnceUpon = factory(global.Backbone, global._)\n}(this, function (Backbone, _) { 'use strict';\n\n  // Shamelessly copying from Marionette bind-entity-events\n\n  function getOption(target, optionName) {\n    if (!target || !optionName) {\n      return;\n    }\n    if (target.options && (target.options[optionName] !== undefined)) {\n      return target.options[optionName];\n    } else {\n      return target[optionName];\n    }\n  };\n\n  // Bind the event to handlers specified as a string of\n  // handler names on the target object\n  function bindFromStrings(target, entity, evt, methods) {\n    let methodNames = methods.split(/\\s+/);\n\n    _.each(methodNames, methodName => {\n      let method = target[methodName];\n      if (!method) {\n        throw new Error('Method \"' + methodName + '\" was configured as an event handler, but does not exist.');\n      }\n      target.listenToOnce(entity, evt, method);\n    });\n  }\n\n  // Bind the event to a supplied callback function\n  function bindToFunction(target, entity, evt, method) {\n    target.listenToOnce(entity, evt, method);\n  }\n\n  // Bind the event to handlers specified as a string of\n  // handler names on the target object\n  function unbindFromStrings(target, entity, evt, methods) {\n    var methodNames = methods.split(/\\s+/);\n\n    _.each(methodNames, methodName => {\n      var method = target[methodName];\n      target.stopListening(entity, evt, method);\n    });\n  }\n\n  // Bind the event to a supplied callback function\n  function unbindToFunction(target, entity, evt, method) {\n    target.stopListening(entity, evt, method);\n  }\n\n  // generic looping function\n  function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n    if (!entity || !bindings) {\n      return;\n    }\n\n    // type-check bindings\n    if (!_.isObject(bindings)) {\n      throw new Error('Bindings must be an object or function.');\n    }\n\n    // allow the bindings to be a function\n    bindings = Marionette._getValue(bindings, target);\n\n    // iterate the bindings and bind them\n    _.each(bindings, (methods, evt) => {\n\n      // allow for a function as the handler,\n      // or a list of event names as a string\n      if (_.isFunction(methods)) {\n        functionCallback(target, entity, evt, methods);\n      } else {\n        stringCallback(target, entity, evt, methods);\n      }\n\n    });\n  }\n\n  // Export Public API\n  Once.bindEntityEvents = function(target, entity, bindings) {\n    iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);\n  };\n\n  Once.unbindEntityEvents = function(target, entity, bindings) {\n    iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);\n  };\n\n  /**\n   *\n   * MyView = Backbone.OnceUpon.extend(Backbone.View) for all views\n   *\n   */\n\n  Backbone.OnceUpon = {\n\n    extend(View) {\n\n      return View.extend({\n\n        delegateEvents() {\n          View.prototype.originalDelegateEvents.apply(this, arguments);\n          bindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n        },\n\n        undelegateEvents() {\n          View.prototype.unbindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n          View.prototype.originalUndelegateEvents.apply(this, arguments);\n        }\n\n      });\n\n    }\n\n  };\n\n  var backbone_onceUpon = Backbone.OnceUpon;\n\n  return backbone_onceUpon;\n\n}));\n","import Backbone from 'backbone';\nimport _ from 'underscore';\n\n// Shamelessly copying from Marionette bind-entity-events\n\nfunction getOption(target, optionName) {\n  if (!target || !optionName) {\n    return;\n  }\n  if (target.options && (target.options[optionName] !== undefined)) {\n    return target.options[optionName];\n  } else {\n    return target[optionName];\n  }\n};\n\n// Bind the event to handlers specified as a string of\n// handler names on the target object\nfunction bindFromStrings(target, entity, evt, methods) {\n  let methodNames = methods.split(/\\s+/);\n\n  _.each(methodNames, methodName => {\n    let method = target[methodName];\n    if (!method) {\n      throw new Error('Method \"' + methodName + '\" was configured as an event handler, but does not exist.');\n    }\n    target.listenToOnce(entity, evt, method);\n  });\n}\n\n// Bind the event to a supplied callback function\nfunction bindToFunction(target, entity, evt, method) {\n  target.listenToOnce(entity, evt, method);\n}\n\n// Bind the event to handlers specified as a string of\n// handler names on the target object\nfunction unbindFromStrings(target, entity, evt, methods) {\n  var methodNames = methods.split(/\\s+/);\n\n  _.each(methodNames, methodName => {\n    var method = target[methodName];\n    target.stopListening(entity, evt, method);\n  });\n}\n\n// Bind the event to a supplied callback function\nfunction unbindToFunction(target, entity, evt, method) {\n  target.stopListening(entity, evt, method);\n}\n\n// generic looping function\nfunction iterateEvents(target, entity, bindings, functionCallback, stringCallback) {\n  if (!entity || !bindings) {\n    return;\n  }\n\n  // type-check bindings\n  if (!_.isObject(bindings)) {\n    throw new Error('Bindings must be an object or function.');\n  }\n\n  // allow the bindings to be a function\n  bindings = Marionette._getValue(bindings, target);\n\n  // iterate the bindings and bind them\n  _.each(bindings, (methods, evt) => {\n\n    // allow for a function as the handler,\n    // or a list of event names as a string\n    if (_.isFunction(methods)) {\n      functionCallback(target, entity, evt, methods);\n    } else {\n      stringCallback(target, entity, evt, methods);\n    }\n\n  });\n}\n\n// Export Public API\nOnce.bindEntityEvents = function(target, entity, bindings) {\n  iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);\n};\n\nOnce.unbindEntityEvents = function(target, entity, bindings) {\n  iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);\n};\n\n/**\n *\n * MyView = Backbone.OnceUpon.extend(Backbone.View) for all views\n *\n */\n\nBackbone.OnceUpon = {\n\n  extend(View) {\n\n    return View.extend({\n\n      delegateEvents() {\n        View.prototype.originalDelegateEvents.apply(this, arguments);\n        bindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n      },\n\n      undelegateEvents() {\n        View.prototype.unbindEntityEvents(this, this, getOption(this, 'onceUponEvents'));\n        View.prototype.originalUndelegateEvents.apply(this, arguments);\n      }\n\n    });\n\n  }\n\n};\n\nexport default Backbone.OnceUpon;\n"],"sourceRoot":"/source/"}